# 并查集

**并查集的初始化：**

```c++
// 最开始，每个节点都单独为一个集合，因此它们的根节点就是自己
for(int i = 1; i <= n; i ++ ) p[i] = i;
```

**一.操作：**

- 操作1：合并两个集合
- 操作2：查询某个元素的祖宗节点

**二.优化：**

- 优化1：路径压缩（常用），时间复杂度 `O(log(n))`

- ```c++
  int find(int x)
  {
      if(p[x] != x) p[x] = find(p[x]);
      return p[x];
  }
  ```

- 优化2：按秩合并，思想：合并两个集合的时候，每次把节点个数或者树的深度较小的一个合并到较大的那一个。`O(log(n))`

**三.扩展：**

- 扩展1：维护上述两个操作的同时，去记录一下每个集合的大小，将这个属性绑定到根节点上。
- 扩展2：记录每个点到根节点的距离，将这个属性绑定到每个元素上。

#### 题目

1250. 格子游戏：

```c++
#include <iostream>
#include <cstdio>
#include <algorithm>

using namespace std;

const int N = 40010;
int p[N];
int n, m;

//把二维的点映射到一维，0序才有这个公式
int get(int x, int y)
{
    return x * n + y;
}

int find(int x)
{
    if(p[x] != x) p[x] = find(p[x]);
    return p[x];
}

int main()
{
    scanf("%d%d", &n, &m);
    
    for(int i = 0; i < n * n; i ++ ) p[i] = i;
    
    int res = 0;
    for(int i = 1; i <= m; i ++ )
    {
        int x, y;  //坐标是1序，切换为0序
        char op[2];
        cin >> x >> y >> op;
        x --, y -- ;
        int a = get(x, y);
        int b = get(x, y + 1);  //另一个点在右边
        if(op[0] == 'D') b = get(x + 1, y);
        
        //合并a，b两个点前先判断是否在一个集合内，如果是，合并就成环了
        int pa = find(a), pb = find(b);  
        if(pa == pb){
            res = i;
            break;
        }else{
            p[pa] = pb;
        }
        
    }
    
    if(!res) puts("draw");
    else printf("%d\n", res);
    
    return 0;
}
```

